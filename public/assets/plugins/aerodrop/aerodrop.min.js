class AeroDrop {
    constructor(element, options = {}) {
        if (!element)
            throw new Error("No element provided to initialize AeroDrop.");

        if (!options.uploadURL) throw new Error("No upload url provided");

        this.element = element;
        this.uploadsInProgress = 0; // Counter to track active uploads

        // Extend default options with generic file size rules
        this.options = Object.assign(
            {
                name: "files",
                maxFiles: null,
                // Fallback limit if no rule matches
                maxFileSize: 2 * 1024 * 1024, // Not used if fileSizeRules are provided
                allowedFileTypes: [
                    "image/jpeg",
                    "image/png",
                    "image/gif",
                    "image/webp",
                    "application/pdf"
                ],
                multiple: true,
                // Callback functions
                onupload: null,
                onuploading: null,
                onerror: null,
                ondiscard: null,
                // New option to allow modifying the xhr before sending
                beforeSend: null,
                // New generic file size rules. Each rule defines an array of MIME types, a maximum file size, and an error message.
                fileSizeRules: [
                    {
                        types: ["image/jpeg", "image/png", "image/webp"],
                        maxSize: 2 * 1024 * 1024, // 2 MB for images
                        error: "Image file too big"
                    },
                    {
                        types: ["application/pdf"],
                        maxSize: 10 * 1024 * 1024, // 10 MB for PDFs
                        error: "PDF file too big"
                    }
                ],
                // Fallback values if no rule matches the file type
                fallbackMaxSize: 10 * 1024 * 1024,
                fallbackError: "File too big"
            },
            options
        );

        // Initialize callback properties so they can be assigned later
        this.onupload = this.options.onupload;
        this.onuploading = this.options.onuploading;
        this.onerror = this.options.onerror;
        this.ondiscard = this.options.ondiscard;

        // If multiple file uploads are allowed, append "[]" to the field name.
        if (this.options.multiple) {
            this.options.name += "[]";
        }

        this.init();
    }

    init() {
        // Clear container content
        this.element.innerHTML =
            '<p class="mb-0 text-muted">Drag &amp; drop files here</p>';

        // Create hidden file input
        this.fileInput = document.createElement("input");
        this.fileInput.type = "file";
        this.fileInput.style.display = "none";
        this.fileInput.multiple = !!this.options.multiple;
        this.element.appendChild(this.fileInput);

        // Create preview container
        this.previewContainer = document.createElement("div");
        this.previewContainer.className = "aerodrop-files";
        this.element.insertAdjacentElement("afterend", this.previewContainer);

        // (Optional) Create a global progress bar container if needed
        this.progressBar = document.createElement("div");
        this.progressBar.className = "aerodrop-progress-bar";
        this.progressBarInner = document.createElement("div");
        this.progressBarInner.className = "aerodrop-progress-bar-inner";
        this.progressBar.appendChild(this.progressBarInner);
        this.element.appendChild(this.progressBar);

        // Bind events including drag & drop events
        this.bindEvents();
    }

    bindEvents() {
        // Clicking anywhere in the container (except on a discard button) opens the file selector
        this.element.addEventListener("click", () => {
            this.fileInput.click();
        });

        // Handle file selection via input
        this.fileInput.addEventListener("change", (e) => {
            const files = e.target.files;
            if (files.length > 0) {
                if (this.options.maxFiles && files.length > this.options.maxFiles) {
                    if (typeof this.onerror === "function") {
                        this.onerror(`Max ${this.options.maxFiles} files allowed`);
                    }
                    return;
                }
                Array.from(files).forEach((file) => {
                    this.handleFile(file);
                });
            }
        });

        // --- Drag and Drop events ---
        ["dragover", "dragenter"].forEach((eventName) => {
            this.element.addEventListener(eventName, (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.element.classList.add("dragover");
            });
        });

        ["dragleave", "dragend"].forEach((eventName) => {
            this.element.addEventListener(eventName, (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.element.classList.remove("dragover");
            });
        });

        this.element.addEventListener("drop", (e) => {
            e.preventDefault();
            e.stopPropagation();
            this.element.classList.remove("dragover");
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                if (this.options.maxFiles && files.length > this.options.maxFiles) {
                    if (typeof this.onerror === "function") {
                        this.onerror(`Max ${this.options.maxFiles} files allowed`);
                    }
                    return;
                }
                Array.from(files).forEach((file) => {
                    this.handleFile(file);
                });
            }
        });
    }

    handleFile(file) {
        const error = this.validateFile(file);
        if (error) {
            if (typeof this.onerror === "function") this.onerror(error);
            this.fileInput.value = "";
            return;
        }
        const previewItem = this.previewFile(file);
        this.uploadFile(file, previewItem);
        this.fileInput.value = "";
    }

    validateFile(file) {
        // First, validate that the file type is allowed.
        if (
            this.options.allowedFileTypes.length > 0 &&
            !this.options.allowedFileTypes.includes(file.type)
        ) {
            return "Invalid file format";
        }

        // Now, use generic file size rules if provided.
        if (this.options.fileSizeRules && Array.isArray(this.options.fileSizeRules)) {
            let ruleMatched = false;
            for (let rule of this.options.fileSizeRules) {
                if (rule.types.includes(file.type)) {
                    ruleMatched = true;
                    if (file.size > rule.maxSize) {
                        return rule.error;
                    }
                }
            }
            // If no rule matched, use the fallback.
            if (!ruleMatched && this.options.fallbackMaxSize && file.size > this.options.fallbackMaxSize) {
                return this.options.fallbackError || "File too big";
            }
        } else {
            // Fallback to using maxFileSize
            if (file.size > this.options.maxFileSize) {
                return "File too big";
            }
        }
        return false;
    }

    previewFile(file) {
        const previewItem = document.createElement("div");
        previewItem.className = "aerodrop-file-item";

        const img = document.createElement("img");
        img.src = file.type.startsWith("image")
            ? URL.createObjectURL(file)
            : "https://upload.wikimedia.org/wikipedia/commons/thumb/0/01/Google_Docs_logo_%282014-2020%29.svg/1481px-Google_Docs_logo_%282014-2020%29.svg.png";
        img.alt = "Preview";
        img.className = "file-preview-img";

        const flexContainer = document.createElement("div");
        flexContainer.className = "flex-grow-1";

        const fileTitle = document.createElement("h6");
        fileTitle.className = "mb-2";
        fileTitle.textContent = file.name || "File Preview";

        const progressContainer = document.createElement("div");
        progressContainer.className = "progress mb-2";

        const progressBar = document.createElement("div");
        progressBar.className = "progress-bar";
        progressBar.setAttribute("role", "progressbar");
        progressBar.style.width = "0%";
        progressBar.setAttribute("aria-valuenow", "0");
        progressBar.textContent = "0%";

        progressContainer.appendChild(progressBar);
        flexContainer.appendChild(fileTitle);
        flexContainer.appendChild(progressContainer);

        const discardButton = document.createElement("button");
        discardButton.setAttribute("type", "button");
        discardButton.className = "discard-btn";
        discardButton.innerHTML =
            '<svg viewBox="0 0 25 25" width="15" height="15" stroke="currentColor" stroke-width="3" fill="none" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>';

        discardButton.addEventListener("click", (ev) => {
            ev.stopPropagation();
            if (previewItem.xhr) {
                previewItem.xhr.abort();
            }
            if (typeof this.ondiscard === "function") {
                this.ondiscard(file);
            }
            previewItem.remove();
        });

        previewItem.appendChild(img);
        previewItem.appendChild(flexContainer);
        previewItem.appendChild(discardButton);
        this.previewContainer.appendChild(previewItem);

        return previewItem;
    }

    uploadFile(file, previewItem) {
        this.uploadsInProgress++;
        this.element.setAttribute("data-loading", "true");

        const progressBar = previewItem.querySelector(".progress-bar");
        const xhr = new XMLHttpRequest();
        xhr.responseType = "json";

        xhr.upload.addEventListener("progress", (event) => {
            if (event.lengthComputable) {
                const progress = Math.round((event.loaded / event.total) * 100);
                progressBar.style.width = progress + "%";
                progressBar.setAttribute("aria-valuenow", progress);
                progressBar.textContent = progress + "%";
                if (typeof this.onuploading === "function") {
                    this.onuploading(file, progress);
                }
            }
        });

        xhr.onload = () => {
            if (xhr.status === 200) {
                if (typeof this.onupload === "function") {
                    this.onupload(xhr.response);
                }
                const successMessage = document.createElement("p");
                successMessage.innerHTML = `Upload successful <svg viewBox="0 0 24 24" width="16" height="16" stroke="green" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>`;
                const hiddenInput = document.createElement("input");
                hiddenInput.type = "hidden";
                hiddenInput.name = this.options.name;
                hiddenInput.value = JSON.stringify({
                    file: xhr.response.file,
                    original_name: xhr.response.original_name,
                    mime_type: xhr.response.mime_type,
                });
                previewItem.querySelector(".progress")?.replaceWith(successMessage);
                previewItem.appendChild(hiddenInput);
            } else {
                if (typeof this.onerror === "function") {
                    this.onerror(xhr);
                }
                previewItem.classList.add("bg-danger", "text-white");
                previewItem.querySelector(".progress")?.replaceWith("Error uploading");
            }
            this.uploadsInProgress--;
            if (this.uploadsInProgress === 0) {
                this.element.removeAttribute("data-loading");
            }
        };

        xhr.onerror = (errorEvent) => {
            if (typeof this.onerror === "function") {
                this.onerror(errorEvent);
            }
            previewItem.classList.add("bg-danger", "text-white");
            previewItem.querySelector(".progress")?.replaceWith("Error uploading");
            this.uploadsInProgress--;
            if (this.uploadsInProgress === 0) {
                this.element.removeAttribute("data-loading");
            }
        };

        xhr.onabort = () => {
            this.uploadsInProgress--;
            if (this.uploadsInProgress === 0) {
                this.element.removeAttribute("data-loading");
            }
        };

        const formData = new FormData();
        formData.append("file", file);

        xhr.open("POST", this.options.uploadURL, true);

        if (typeof this.options.beforeSend === "function") {
            this.options.beforeSend(xhr);
        }

        xhr.send(formData);
        previewItem.xhr = xhr;
    }
}
