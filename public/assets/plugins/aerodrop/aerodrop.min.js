class AeroDrop {
    constructor(element, options = {}) {
        if (!element)
            throw new Error("No element provided to initialize AeroDrop.");

        if (!options.uploadURL) throw new Error("No upload url provided");

        this.element = element;
        this.uploadsInProgress = 0; // Counter to track active uploads
        this.totalFiles = 0; // Add a counter to track total files

        // Extend default options with generic file size rules
        this.options = Object.assign(
            {
                name: "files",
                maxFiles: null,
                enableCamera: false, // Add this line
                // Fallback limit if no rule matches
                maxFileSize: 2 * 1024 * 1024, // Not used if fileSizeRules are provided
                allowedFileTypes: [
                    "image/jpeg",
                    "image/png",
                    "image/gif",
                    "image/webp",
                    "application/pdf"
                ],
                multiple: true,
                // Callback functions
                onupload: null,
                onuploading: null,
                onerror: null,
                ondiscard: null,
                // New option to allow modifying the xhr before sending
                beforeSend: null,
                // New generic file size rules. Each rule defines an array of MIME types, a maximum file size, and an error message.
                fileSizeRules: [
                    {
                        types: ["image/jpeg", "image/png", "image/webp"],
                        maxSize: 2 * 1024 * 1024, // 2 MB for images
                        error: "Image file too big"
                    },
                    {
                        types: ["application/pdf"],
                        maxSize: 10 * 1024 * 1024, // 10 MB for PDFs
                        error: "PDF file too big"
                    }
                ],
                // Fallback values if no rule matches the file type
                fallbackMaxSize: 10 * 1024 * 1024,
                fallbackError: "File too big"
            },
            options
        );

        // Initialize callback properties so they can be assigned later
        this.onupload = this.options.onupload;
        this.onuploading = this.options.onuploading;
        this.onerror = this.options.onerror;
        this.ondiscard = this.options.ondiscard;

        // If multiple file uploads are allowed, append "[]" to the field name.
        if (this.options.multiple) {
            this.options.name += "[]";
        }

        this.init();
    }

    init() {
        // Clear container content with additional camera button if enabled
        let content = '<p class="mb-0 text-muted">Drag &amp; drop files here</p>';
        if (this.options.enableCamera) {
            content += `
                <button type="button" class="btn btn-sm btn-outline-secondary mt-3 camera-btn"
                    <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2" fill="none">
                        <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
                        <circle cx="12" cy="13" r="4"/>
                    </svg>
                    <span>Take Photo</span>
                </button>`;
        }
        this.element.innerHTML = content;

        // Create hidden file input
        this.fileInput = document.createElement("input");
        this.fileInput.type = "file";
        this.fileInput.style.display = "none";
        this.fileInput.multiple = !!this.options.multiple;
        this.element.appendChild(this.fileInput);

        // Create preview container
        this.previewContainer = document.createElement("div");
        this.previewContainer.className = "aerodrop-files";
        this.element.insertAdjacentElement("afterend", this.previewContainer);

        // (Optional) Create a global progress bar container if needed
        this.progressBar = document.createElement("div");
        this.progressBar.className = "aerodrop-progress-bar";
        this.progressBarInner = document.createElement("div");
        this.progressBarInner.className = "aerodrop-progress-bar-inner";
        this.progressBar.appendChild(this.progressBarInner);
        this.element.appendChild(this.progressBar);

        // Bind events including drag & drop events
        this.bindEvents();
    }

    bindEvents() {
        // Clicking anywhere in the container (except on a discard button) opens the file selector
        this.element.addEventListener("click", () => {
            this.fileInput.click();
        });

        // Handle file selection via input
        this.fileInput.addEventListener("change", (e) => {
            const files = e.target.files;
            if (files.length > 0) {
                // Check if adding these files would exceed maxFiles
                if (this.options.maxFiles && this.totalFiles + files.length > this.options.maxFiles) {
                    if (typeof this.onerror === "function") {
                        this.onerror(`Max ${this.options.maxFiles} files allowed`);
                    }
                    return;
                }
                Array.from(files).forEach((file) => {
                    this.handleFile(file);
                });
            }
        });

        // --- Drag and Drop events ---
        ["dragover", "dragenter"].forEach((eventName) => {
            this.element.addEventListener(eventName, (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.element.classList.add("dragover");
            });
        });

        ["dragleave", "dragend"].forEach((eventName) => {
            this.element.addEventListener(eventName, (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.element.classList.remove("dragover");
            });
        });

        this.element.addEventListener("drop", (e) => {
            e.preventDefault();
            e.stopPropagation();
            this.element.classList.remove("dragover");
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                // Check if adding these files would exceed maxFiles
                if (this.options.maxFiles && this.totalFiles + files.length > this.options.maxFiles) {
                    if (typeof this.onerror === "function") {
                        this.onerror(`Max ${this.options.maxFiles} files allowed`);
                    }
                    return;
                }
                Array.from(files).forEach((file) => {
                    this.handleFile(file);
                });
            }
        });

        // Add camera button click handler
        if (this.options.enableCamera) {
            const cameraBtn = this.element.querySelector('.camera-btn');
            cameraBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                this.openCamera();
            });
        }
    }

    handleFile(file) {
        const error = this.validateFile(file);
        if (error) {
            if (typeof this.onerror === "function") this.onerror(error);
            this.fileInput.value = "";
            return;
        }
        const previewItem = this.previewFile(file);
        this.uploadFile(file, previewItem);
        this.fileInput.value = "";
    }

    validateFile(file) {
        // First, validate that the file type is allowed.
        if (
            this.options.allowedFileTypes.length > 0 &&
            !this.options.allowedFileTypes.includes(file.type)
        ) {
            return "Invalid file format";
        }

        // Now, use generic file size rules if provided.
        if (this.options.fileSizeRules && Array.isArray(this.options.fileSizeRules)) {
            let ruleMatched = false;
            for (let rule of this.options.fileSizeRules) {
                if (rule.types.includes(file.type)) {
                    ruleMatched = true;
                    if (file.size > rule.maxSize) {
                        return rule.error ?? "File too big";
                    }
                }
            }
            // If no rule matched, use the fallback.
            if (!ruleMatched && this.options.fallbackMaxSize && file.size > this.options.fallbackMaxSize) {
                return this.options.fallbackError || "File too big";
            }
        } else {
            // Fallback to using maxFileSize
            if (file.size > this.options.maxFileSize) {
                return "File too big";
            }
        }
        return false;
    }

    previewFile(file) {
        // Increment total file count when adding a preview
        this.totalFiles++;
        
        const previewItem = document.createElement("div");
        previewItem.className = "aerodrop-file-item";

        const img = document.createElement("img");
        img.src = file.type.startsWith("image")
            ? URL.createObjectURL(file)
            : "https://upload.wikimedia.org/wikipedia/commons/thumb/0/01/Google_Docs_logo_%282014-2020%29.svg/1481px-Google_Docs_logo_%282014-2020%29.svg.png";
        img.alt = "Preview";
        img.className = "file-preview-img";

        const flexContainer = document.createElement("div");
        flexContainer.className = "flex-grow-1";

        const fileTitle = document.createElement("h6");
        fileTitle.className = "mb-2";
        fileTitle.textContent = file.name || "File Preview";

        const progressContainer = document.createElement("div");
        progressContainer.className = "progress mb-2";

        const progressBar = document.createElement("div");
        progressBar.className = "progress-bar";
        progressBar.setAttribute("role", "progressbar");
        progressBar.style.width = "0%";
        progressBar.setAttribute("aria-valuenow", "0");
        progressBar.textContent = "0%";

        progressContainer.appendChild(progressBar);
        flexContainer.appendChild(fileTitle);
        flexContainer.appendChild(progressContainer);

        const discardButton = document.createElement("button");
        discardButton.setAttribute("type", "button");
        discardButton.className = "discard-btn";
        discardButton.innerHTML =
            '<svg viewBox="0 0 25 25" width="15" height="15" stroke="currentColor" stroke-width="3" fill="none" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>';

        discardButton.addEventListener("click", (ev) => {
            ev.stopPropagation();
            if (previewItem.xhr) {
                previewItem.xhr.abort();
            }
            if (typeof this.ondiscard === "function") {
                this.ondiscard(file);
            }
            previewItem.remove();
            // Decrement total file count when removing a file
            this.totalFiles--;
        });

        previewItem.appendChild(img);
        previewItem.appendChild(flexContainer);
        previewItem.appendChild(discardButton);
        this.previewContainer.prepend(previewItem);

        return previewItem;
    }

    uploadFile(file, previewItem) {
        this.uploadsInProgress++;
        this.element.setAttribute("data-loading", "true");

        const progressBar = previewItem.querySelector(".progress-bar");
        const xhr = new XMLHttpRequest();
        xhr.responseType = "json";

        xhr.upload.addEventListener("progress", (event) => {
            if (event.lengthComputable) {
                const progress = Math.round((event.loaded / event.total) * 100);
                progressBar.style.width = progress + "%";
                progressBar.setAttribute("aria-valuenow", progress);
                progressBar.textContent = progress + "%";
                if (typeof this.onuploading === "function") {
                    this.onuploading(file, progress);
                }
            }
        });

        xhr.onload = () => {
            if (xhr.status === 200) {
                if (typeof this.onupload === "function") {
                    this.onupload(xhr.response);
                }
                const successMessage = document.createElement("p");
                successMessage.innerHTML = `Upload successful <svg viewBox="0 0 24 24" width="16" height="16" stroke="green" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>`;
                
                const hiddenInput = document.createElement("input");
                hiddenInput.type = "hidden";
                hiddenInput.name = this.options.name;
                hiddenInput.value = JSON.stringify(xhr.response);
                
                previewItem.querySelector(".progress")?.replaceWith(successMessage);
                previewItem.appendChild(hiddenInput);
            } else {
                if (typeof this.onerror === "function") {
                    this.onerror(xhr);
                }
                previewItem.classList.add("bg-danger", "text-white");
                previewItem.querySelector(".progress")?.replaceWith("Error uploading");
                
                // Decrement total file count when upload fails
                this.totalFiles--;
            }
            this.uploadsInProgress--;
            if (this.uploadsInProgress === 0) {
                this.element.removeAttribute("data-loading");
            }
        };

        xhr.onerror = (errorEvent) => {
            if (typeof this.onerror === "function") {
                this.onerror(errorEvent);
            }
            previewItem.classList.add("bg-danger", "text-white");
            previewItem.querySelector(".progress")?.replaceWith("Error uploading");
            
            // Decrement total file count when upload errors out
            this.totalFiles--;
            
            this.uploadsInProgress--;
            if (this.uploadsInProgress === 0) {
                this.element.removeAttribute("data-loading");
            }
        };

        xhr.onabort = () => {
            // Don't need to decrement totalFiles here as the discard button handler already does it
            this.uploadsInProgress--;
            if (this.uploadsInProgress === 0) {
                this.element.removeAttribute("data-loading");
            }
        };

        const formData = new FormData();
        formData.append("file", file);

        xhr.open("POST", this.options.uploadURL, true);

        if (typeof this.options.beforeSend === "function") {
            this.options.beforeSend(xhr);
        }

        xhr.send(formData);
        previewItem.xhr = xhr;
    }

    openCamera() {
        navigator.mediaDevices.getUserMedia({ video: true })
            .then(stream => {
                const videoModal = document.createElement('div');
                videoModal.className = 'aerodrop-camera-modal';
                videoModal.innerHTML = `
                    <div class="camera-content d-flex flex-column align-items-center p-2">
                        <video autoplay style="width: 100%"></video>
                        <div class="camera-controls d-flex justify-content-between gap-2 mt-2">
                            <button type="button" class="btn btn-sm btn-primary capture-btn">
                                <svg viewBox="0 0 24 24" width="16" height="16" stroke="currentColor" stroke-width="2" fill="none">
                                    <polyline points="20 6 9 17 4 12"></polyline>
                                </svg>
                            </button>
                            <button type="button" class="btn btn-sm btn-danger close-btn">
                                <svg viewBox="0 0 24 24" width="16" height="16" stroke="currentColor" stroke-width="2" fill="none">
                                    <line x1="18" y1="6" x2="6" y2="18"></line>
                                    <line x1="6" y1="6" x2="18" y2="18"></line>
                                </svg>
                            </button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(videoModal);
                
                const video = videoModal.querySelector('video');
                video.srcObject = stream;
                
                const captureBtn = videoModal.querySelector('.capture-btn');
                const closeBtn = videoModal.querySelector('.close-btn');
                
                captureBtn.addEventListener('click', () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    canvas.getContext('2d').drawImage(video, 0, 0);
                    
                    canvas.toBlob(blob => {
                        const file = new File([blob], "camera-photo.jpg", { type: 'image/jpeg' });
                        this.handleFile(file);
                        
                        // Clean up
                        stream.getTracks().forEach(track => track.stop());
                        videoModal.remove();
                    }, 'image/jpeg');
                });
                
                closeBtn.addEventListener('click', () => {
                    stream.getTracks().forEach(track => track.stop());
                    videoModal.remove();
                });
            })
            .catch(err => {
                if (typeof this.onerror === "function") {
                    this.onerror("Camera access denied or not available");
                }
            });
    }
}
